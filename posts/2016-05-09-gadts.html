<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" class="wf-loading"><head>
       <script src="https://use.typekit.net/geg0pqq.js"></script><script>
        (function(d) {
          var config = {
            kitId: 'geg0pqq',
            scriptTimeout: 3000,
            async: true
          },
          h=d.documentElement,t=setTimeout(function(){h.className=h.className.replace(/\bwf-loading\b/g,"")+" wf-inactive";},config.scriptTimeout),tk=d.createElement("script"),f=false,s=d.getElementsByTagName("script")[0],a;h.className+=" wf-loading";tk.src='https://use.typekit.net/'+config.kitId+'.js';tk.async=true;tk.onload=tk.onreadystatechange=function(){a=this.readyState;if(f||a&&a!="complete"&&a!="loaded")return;f=true;clearTimeout(t);try{Typekit.load(config)}catch(e){}};s.parentNode.insertBefore(tk,s)
        })(document);
    </script>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Generalized Algebraic Data Types I</title>
    <!--
     <script type="text/x-mathjax-config">
            MathJax.Hub.Config({
                displayAlign: "left",
                showProcessingMessages: false,
                showMathMenu: true,
                messageStyle: "none",
                TeX: { TagSide: "left", equationNumbers: { autoNumber: "AMS" } }
            });
        </script>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
        </script>
        -->
   <link rel="stylesheet" type="text/css" href="../css/tufte.css"><style type="text/css">.tk-minion-pro-caption{font-family:"minion-pro-caption",sans-serif;}.tk-minion-pro-display{font-family:"minion-pro-display",serif;}</style><link rel="stylesheet" href="https://use.typekit.net/c/855fba/1w;minion-pro-caption,7ceb210e49ade74e23101e10f006f110a0b6588c7c57777a6e3d98a38b749696,bzc:W:i4,bzb:W:n4,bzj:W:n7;minion-pro-display,7ceb210e49ade74e23101e10f006f110a0b6588c7c57777a6e3d98a38b749696,c0F:W:i4,c0J:W:n4,c0C:W:n7/k" media="all">
  </head>

  <body><style id="MathJax_CHTML_styles">.mjx-chtml {display: inline-block; line-height: 0; text-indent: 0; text-align: left; text-transform: none; font-style: normal; font-weight: normal; font-size: 100%; font-size-adjust: none; letter-spacing: normal; word-wrap: normal; word-spacing: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; margin: 0; padding: 1px 0}
.MJXc-display {display: block; text-align: center; margin: 1em 0; padding: 0}
.mjx-chtml[tabindex]:focus, body :focus .mjx-chtml[tabindex] {display: inline-table}
.mjx-math {display: inline-block; border-collapse: separate; border-spacing: 0}
.mjx-math * {display: inline-block; text-align: left}
.mjx-numerator {display: block; text-align: center}
.mjx-denominator {display: block; text-align: center}
.MJXc-stacked {height: 0; position: relative}
.MJXc-stacked > * {position: absolute}
.MJXc-bevelled > * {display: inline-block}
.mjx-stack {display: inline-block}
.mjx-op {display: block}
.mjx-under {display: table-cell}
.mjx-over {display: block}
.mjx-over > * {padding-left: 0px!important; padding-right: 0px!important}
.mjx-under > * {padding-left: 0px!important; padding-right: 0px!important}
.mjx-stack > .mjx-sup {display: block}
.mjx-stack > .mjx-sub {display: block}
.mjx-prestack > .mjx-presup {display: block}
.mjx-prestack > .mjx-presub {display: block}
.mjx-delim-h > .mjx-char {display: inline-block}
.mjx-surd {vertical-align: top}
.mjx-mphantom * {visibility: hidden}
.mjx-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 2px 3px; font-style: normal; font-size: 90%}
.mjx-annotation-xml {line-height: normal}
.mjx-menclose > svg {fill: none; stroke: currentColor}
.mjx-mtr {display: table-row}
.mjx-mlabeledtr {display: table-row}
.mjx-mtd {display: table-cell; text-align: center}
.mjx-label {display: block}
.mjx-box {display: inline-block}
.mjx-block {display: block}
.mjx-span {display: span}
.mjx-char {display: block; white-space: pre}
.mjx-itable {display: inline-table}
.mjx-row {display: table-row}
.mjx-cell {display: table-cell}
.mjx-table {display: table; width: 100%}
.mjx-line {display: block; height: 0}
.mjx-strut {width: 0; padding-top: 1em}
.mjx-vsize {width: 0}
.MJXc-space1 {margin-left: .167em}
.MJXc-space2 {margin-left: .222em}
.MJXc-space3 {margin-left: .278em}
.mjx-ex-box-test {position: absolute; width: 1px; height: 60ex}
.MJXc-TeX-unknown-R {font-family: monospace; font-style: normal; font-weight: normal}
.MJXc-TeX-unknown-I {font-family: monospace; font-style: italic; font-weight: normal}
.MJXc-TeX-unknown-B {font-family: monospace; font-style: normal; font-weight: bold}
.MJXc-TeX-unknown-BI {font-family: monospace; font-style: italic; font-weight: bold}
.MJXc-TeX-ams-R {font-family: MJXc-TeX-ams-R,MJXc-TeX-ams-Rw}
.MJXc-TeX-cal-B {font-family: MJXc-TeX-cal-B,MJXc-TeX-cal-Bx,MJXc-TeX-cal-Bw}
.MJXc-TeX-frak-R {font-family: MJXc-TeX-frak-R,MJXc-TeX-frak-Rw}
.MJXc-TeX-frak-B {font-family: MJXc-TeX-frak-B,MJXc-TeX-frak-Bx,MJXc-TeX-frak-Bw}
.MJXc-TeX-math-BI {font-family: MJXc-TeX-math-BI,MJXc-TeX-math-BIx,MJXc-TeX-math-BIw}
.MJXc-TeX-sans-R {font-family: MJXc-TeX-sans-R,MJXc-TeX-sans-Rw}
.MJXc-TeX-sans-B {font-family: MJXc-TeX-sans-B,MJXc-TeX-sans-Bx,MJXc-TeX-sans-Bw}
.MJXc-TeX-sans-I {font-family: MJXc-TeX-sans-I,MJXc-TeX-sans-Ix,MJXc-TeX-sans-Iw}
.MJXc-TeX-script-R {font-family: MJXc-TeX-script-R,MJXc-TeX-script-Rw}
.MJXc-TeX-type-R {font-family: MJXc-TeX-type-R,MJXc-TeX-type-Rw}
.MJXc-TeX-cal-R {font-family: MJXc-TeX-cal-R,MJXc-TeX-cal-Rw}
.MJXc-TeX-main-B {font-family: MJXc-TeX-main-B,MJXc-TeX-main-Bx,MJXc-TeX-main-Bw}
.MJXc-TeX-main-I {font-family: MJXc-TeX-main-I,MJXc-TeX-main-Ix,MJXc-TeX-main-Iw}
.MJXc-TeX-main-R {font-family: MJXc-TeX-main-R,MJXc-TeX-main-Rw}
.MJXc-TeX-math-I {font-family: MJXc-TeX-math-I,MJXc-TeX-math-Ix,MJXc-TeX-math-Iw}
.MJXc-TeX-size1-R {font-family: MJXc-TeX-size1-R,MJXc-TeX-size1-Rw}
.MJXc-TeX-size2-R {font-family: MJXc-TeX-size2-R,MJXc-TeX-size2-Rw}
.MJXc-TeX-size3-R {font-family: MJXc-TeX-size3-R,MJXc-TeX-size3-Rw}
.MJXc-TeX-size4-R {font-family: MJXc-TeX-size4-R,MJXc-TeX-size4-Rw}
@font-face {font-family: MJXc-TeX-ams-R; src: local('MathJax_AMS'), local('MathJax_AMS-Regular')}
@font-face {font-family: MJXc-TeX-ams-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_AMS-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_AMS-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_AMS-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-cal-B; src: local('MathJax_Caligraphic Bold'), local('MathJax_Caligraphic-Bold')}
@font-face {font-family: MJXc-TeX-cal-Bx; src: local('MathJax_Caligraphic'); font-weight: bold}
@font-face {font-family: MJXc-TeX-cal-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Caligraphic-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-frak-R; src: local('MathJax_Fraktur'), local('MathJax_Fraktur-Regular')}
@font-face {font-family: MJXc-TeX-frak-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Fraktur-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Fraktur-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Fraktur-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-frak-B; src: local('MathJax_Fraktur Bold'), local('MathJax_Fraktur-Bold')}
@font-face {font-family: MJXc-TeX-frak-Bx; src: local('MathJax_Fraktur'); font-weight: bold}
@font-face {font-family: MJXc-TeX-frak-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Fraktur-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Fraktur-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Fraktur-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-math-BI; src: local('MathJax_Math BoldItalic'), local('MathJax_Math-BoldItalic')}
@font-face {font-family: MJXc-TeX-math-BIx; src: local('MathJax_Math'); font-weight: bold; font-style: italic}
@font-face {font-family: MJXc-TeX-math-BIw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Math-BoldItalic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-BoldItalic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-BoldItalic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-sans-R; src: local('MathJax_SansSerif'), local('MathJax_SansSerif-Regular')}
@font-face {font-family: MJXc-TeX-sans-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_SansSerif-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-sans-B; src: local('MathJax_SansSerif Bold'), local('MathJax_SansSerif-Bold')}
@font-face {font-family: MJXc-TeX-sans-Bx; src: local('MathJax_SansSerif'); font-weight: bold}
@font-face {font-family: MJXc-TeX-sans-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_SansSerif-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-sans-I; src: local('MathJax_SansSerif Italic'), local('MathJax_SansSerif-Italic')}
@font-face {font-family: MJXc-TeX-sans-Ix; src: local('MathJax_SansSerif'); font-style: italic}
@font-face {font-family: MJXc-TeX-sans-Iw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_SansSerif-Italic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_SansSerif-Italic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_SansSerif-Italic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-script-R; src: local('MathJax_Script'), local('MathJax_Script-Regular')}
@font-face {font-family: MJXc-TeX-script-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Script-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Script-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Script-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-type-R; src: local('MathJax_Typewriter'), local('MathJax_Typewriter-Regular')}
@font-face {font-family: MJXc-TeX-type-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Typewriter-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Typewriter-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Typewriter-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-cal-R; src: local('MathJax_Caligraphic'), local('MathJax_Caligraphic-Regular')}
@font-face {font-family: MJXc-TeX-cal-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Caligraphic-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-main-B; src: local('MathJax_Main Bold'), local('MathJax_Main-Bold')}
@font-face {font-family: MJXc-TeX-main-Bx; src: local('MathJax_Main'); font-weight: bold}
@font-face {font-family: MJXc-TeX-main-Bw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Main-Bold.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-main-I; src: local('MathJax_Main Italic'), local('MathJax_Main-Italic')}
@font-face {font-family: MJXc-TeX-main-Ix; src: local('MathJax_Main'); font-style: italic}
@font-face {font-family: MJXc-TeX-main-Iw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Main-Italic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-main-R; src: local('MathJax_Main'), local('MathJax_Main-Regular')}
@font-face {font-family: MJXc-TeX-main-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Main-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-math-I; src: local('MathJax_Math Italic'), local('MathJax_Math-Italic')}
@font-face {font-family: MJXc-TeX-math-Ix; src: local('MathJax_Math'); font-style: italic}
@font-face {font-family: MJXc-TeX-math-Iw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Math-Italic.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size1-R; src: local('MathJax_Size1'), local('MathJax_Size1-Regular')}
@font-face {font-family: MJXc-TeX-size1-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size1-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size2-R; src: local('MathJax_Size2'), local('MathJax_Size2-Regular')}
@font-face {font-family: MJXc-TeX-size2-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size2-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size3-R; src: local('MathJax_Size3'), local('MathJax_Size3-Regular')}
@font-face {font-family: MJXc-TeX-size3-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size3-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf') format('opentype')}
@font-face {font-family: MJXc-TeX-size4-R; src: local('MathJax_Size4'), local('MathJax_Size4-Regular')}
@font-face {font-family: MJXc-TeX-size4-Rw; src /*1*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/eot/MathJax_Size4-Regular.eot'); src /*2*/: url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff') format('woff'), url('https://cdn.mathjax.org/mathjax/latest/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf') format('opentype')}
</style>
    <main role="main">
    <article class="row article post" role="article">
      <div class="cell">
        <header class="row">
          <div class="home">
            <a href="../">Blog</a>
            <a href="../archive.html">Archive</a>
            <a href="../projects.html">Projects</a>
          </div>
        </header>
          <h1 class="preview-title">Generalized Algebraic Data Types I</h1> 
<div class="preview-info">

  Part IV of the series <i>Fun with Functional C#</i>.

<div><i>May  9, 2016</i></div>
</div>
<p>

</p><p>This is the first of two articles on GADTs. This first part will be a general introduction to GADTs and their utility, while the second part will show how we can wrangle GADT behaviour out of C#.</p>
<p>The canonical GADT introduction involves a demonstration of the inadequacy of algebraic data types. But since this is written from a C# perspective, and C# doesn’t have GADTs, we’ll start with a brief introduction to vanilla ADTs.</p>
<h2 id="algebraic-data-types">Algebraic Data Types</h2>
<p>Algebraic data types allow us a sort of type-level composition that’s more rigorous than what we have in C#. There are two ways to compose types in this algebra: products and sums, which are roughly analogous<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> to products and sums over the integers.</p>
<h3 id="product-types">Product types</h3>
<p>Product types allow us to combine two or more types into one compound type. In Haskell, we can combine two types into a pair:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Pair</span> a b <span class="fu">=</span> <span class="dt">Pair</span> a b</code></pre></div>
<!--more-->
<p>Even though there are some important differences, at first this doesn’t seem all too different from what we might write in C#:</p>
<div class="sourceCode"><pre class="sourceCode cs"><code class="sourceCode cs"><span class="kw">class</span> Pair&lt;A, B&gt; {
  A a;
  B b;
}</code></pre></div>
<p>We can now encode tuples of arbitrary size by nesting <code>Pair</code> constructors. For example:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">triple ::</span> <span class="dt">Pair</span> (<span class="dt">Pair</span> <span class="dt">String</span> <span class="dt">Int</span>) <span class="dt">Int</span>
triple <span class="fu">=</span> <span class="dt">Pair</span> (<span class="dt">Pair</span> <span class="st">"one"</span> <span class="dv">2</span>) <span class="dv">3</span></code></pre></div>
<p>is equivalent to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">triple' ::</span> (<span class="dt">String</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)
triple' <span class="fu">=</span> (<span class="st">"one"</span>, <span class="dv">2</span>, <span class="dv">3</span>)</code></pre></div>
<p>We’ll use the more compact tuple notation from now on.</p>
<h3 id="sum-types">Sum types</h3>
<p>While a product type <code>(a, b)</code> is effectively a type that is <em>both</em> <code>a</code> and <code>b</code>, a sum type <code>Sum a b</code> is a type that can only be <em>either</em> <code>a</code> or <code>b</code>. In Haskell, we represent sum types like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="dt">Left</span> a <span class="fu">|</span> <span class="dt">Right</span> b</code></pre></div>
<h2 id="an-expression-evaluator">An expression evaluator</h2>
<p>We’re now ready for the canonical GADT introduction.</p>
<p>Let’s say we want to represent expressions for a simple calculator. We can do this with ADTs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr</span> <span class="fu">=</span> <span class="dt">Val</span> <span class="dt">Int</span>
          <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span>
          <span class="fu">|</span> <span class="dt">Mult</span> <span class="dt">Expr</span> <span class="dt">Expr</span></code></pre></div>
<p>We can now represent expressions like <code>6 * ((3 * 4) + (5 + 9))</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">expr1 <span class="fu">=</span> <span class="dt">Mult</span> (<span class="dt">Val</span> <span class="dv">6</span>) (<span class="dt">Add</span> (<span class="dt">Mult</span> (<span class="dt">Val</span> <span class="dv">3</span>) (<span class="dt">Val</span> <span class="dv">4</span>)) (<span class="dt">Add</span> (<span class="dt">Val</span> <span class="dv">5</span>) (<span class="dt">Val</span> <span class="dv">9</span>)))</code></pre></div>
<p>Now we can very easily write an evaluator that will work for arbitrarily complex expressions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
eval (<span class="dt">Val</span> x) <span class="fu">=</span> x
eval (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">+</span> eval e2
eval (<span class="dt">Mult</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">*</span> eval e2</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> eval expr1
<span class="dv">156</span></code></pre></div>
<p>Because the evaluation and representation are separate, we can write multiple evaluators, like a pretty printer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">pretty ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">String</span>
pretty (<span class="dt">Val</span> x) <span class="fu">=</span> show x
pretty (<span class="dt">Add</span> e1 e2) <span class="fu">=</span> <span class="st">"("</span> <span class="fu">++</span> pretty e1 <span class="fu">++</span> <span class="st">" + "</span> <span class="fu">++</span> pretty e2 <span class="fu">++</span> <span class="st">")"</span>
pretty (<span class="dt">Mult</span> e1 e2) <span class="fu">=</span> <span class="st">"("</span> <span class="fu">++</span> pretty e1 <span class="fu">++</span> <span class="st">" * "</span> <span class="fu">++</span> pretty e2 <span class="fu">++</span> <span class="st">")"</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> pretty expr1
<span class="st">"(6 * ((3 * 4) + (5 + 9)))"</span></code></pre></div>
<h3 id="extending-the-expression">Extending the expression</h3>
<p>The allure of this style is clear; we have a declarative representation of our data, and we can interpret it in various ways by simply defining a function from <code>Expr -&gt; a</code>, for any <code>a</code> we choose.</p>
<p>Let’s extend our expression type, and see if we can maintain this elegant style.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Expr'</span> <span class="fu">=</span> <span class="dt">IntVal</span> <span class="dt">Int</span>
           <span class="fu">|</span> <span class="dt">BoolVal</span> <span class="dt">Bool</span>
           <span class="fu">|</span> <span class="dt">AddInt</span> <span class="dt">Expr'</span> <span class="dt">Expr'</span>
           <span class="fu">|</span> <span class="dt">MultInt</span> <span class="dt">Expr'</span> <span class="dt">Expr'</span>
           <span class="fu">|</span> <span class="dt">GreaterThan</span> <span class="dt">Expr'</span> <span class="dt">Expr'</span></code></pre></div>
<p>Now we have a greater than operation that can evaluate to a boolean, allowing us to represent expressions like <code>3 + (2 * 4) &gt; 9 * (9 + 2)</code>, which should ideally evaluate to <code>False</code>.</p>
<p>How would we go about writing our evaluator? Well, we could either return an <code>Int</code> or a <code>Bool</code>, so our type should be <code>Either Int Bool</code>.</p>
<p>But hang on, we have <code>MultInt Expr' Expr'</code>, which means <code>MultInt</code> accepts <em>anything</em> of type <code>Expr'</code>, even <code>BoolVal</code>! We could write something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">MultInt</span> (<span class="dt">GreaterThan</span> (<span class="dt">AddInt</span> (<span class="dt">IntVal</span> <span class="dv">3</span>) (<span class="dt">IntVal</span> <span class="dv">4</span>)) (<span class="dt">IntVal</span> <span class="dv">2</span>)) (<span class="dt">IntVal</span> <span class="dv">9</span>))</code></pre></div>
<p>This is effectively <code>((3 + 4) &gt; 2) * 9</code>, which simplifies to <code>False * 9</code>, which is clearly nonsensical. This is a valid value of <code>Expr'</code>, however, so we need to represent the possibility that the evaluation can fail by wrapping the return type in a <code>Maybe</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval' ::</span> <span class="dt">Expr'</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Bool</span>)
eval' (<span class="dt">AddInt</span> e1 e2) <span class="fu">=</span> <span class="kw">case</span> (eval' e1, eval' e2) <span class="kw">of</span>
  (<span class="dt">Just</span> (<span class="dt">Left</span> i1), <span class="dt">Just</span> (<span class="dt">Left</span> i2)) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Left</span> <span class="fu">$</span> i1 <span class="fu">+</span> i2)
  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
eval' (<span class="dt">MultInt</span> e1 e2) <span class="fu">=</span> <span class="kw">case</span> (eval' e1, eval' e2) <span class="kw">of</span>
  (<span class="dt">Just</span> (<span class="dt">Left</span> i1), <span class="dt">Just</span> (<span class="dt">Left</span> i2)) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Left</span> <span class="fu">$</span> i1 <span class="fu">*</span> i2)
  _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>
eval' (<span class="dt">GreaterThan</span> e1 e2) <span class="fu">=</span> <span class="kw">case</span> (eval' e1, eval' e2) <span class="kw">of</span>
  (<span class="dt">Just</span> (<span class="dt">Left</span> i1), <span class="dt">Just</span> (<span class="dt">Left</span> i2)) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Right</span> <span class="fu">$</span> i1 <span class="fu">&gt;</span> i2)
eval' (<span class="dt">IntVal</span> x) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Left</span> x)
eval' (<span class="dt">BoolVal</span> b) <span class="fu">=</span> <span class="dt">Just</span> (<span class="dt">Right</span> b)</code></pre></div>
<p>This works as expected:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="co">-- 3 &gt; 2:</span>
ghci<span class="fu">&gt;</span> eval' <span class="fu">$</span> <span class="dt">GreaterThan</span> (<span class="dt">IntVal</span> <span class="dv">3</span>) (<span class="dt">IntVal</span> <span class="dv">2</span>)
<span class="dt">Just</span> (<span class="dt">Right</span> <span class="dt">True</span>)

ghci<span class="fu">&gt;</span> <span class="co">-- (3 + 5) &gt; 2:</span>
ghci<span class="fu">&gt;</span> eval' <span class="fu">$</span> <span class="dt">GreaterThan</span> (<span class="dt">AddInt</span> (<span class="dt">IntVal</span> <span class="dv">3</span>) (<span class="dt">IntVal</span> <span class="dv">5</span>)) (<span class="dt">IntVal</span> <span class="dv">2</span>)
<span class="dt">Just</span> (<span class="dt">Right</span> <span class="dt">False</span>)

ghci<span class="fu">&gt;</span> <span class="co">-- (5 &gt; 2) * 6:</span>
ghci<span class="fu">&gt;</span> eval' <span class="fu">$</span> <span class="dt">MultInt</span> (<span class="dt">GreaterThan</span> (<span class="dt">IntVal</span> <span class="dv">5</span>) (<span class="dt">IntVal</span> <span class="dv">2</span>)) (<span class="dt">IntVal</span> <span class="dv">6</span>)
<span class="dt">Nothing</span></code></pre></div>
<p>But we’ve completely lost the elegance and obviousness of the initial implementation. And this is a relatively simple evaluator; a more complex evaluator will be almost entirely consumed with complex and error-prone logic for validating expressions.</p>
<h2 id="a-better-solution">A better solution?</h2>
<p>A better solution would be to make invalid expressions fail to typecheck, and offload all this tedious logic to the compiler:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BetterExpr</span> t <span class="fu">=</span>
    <span class="dt">IntVal</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">BoolVal</span> <span class="dt">Bool</span>
  <span class="fu">|</span> <span class="dt">MultInt</span> (<span class="dt">BetterExpr</span> <span class="dt">Int</span>) (<span class="dt">BetterExpr</span> <span class="dt">Int</span>)
  <span class="fu">|</span> <span class="dt">AddInt</span> (<span class="dt">BetterExpr</span> <span class="dt">Int</span>) (<span class="dt">BetterExpr</span> <span class="dt">Int</span>)
  <span class="fu">|</span> <span class="dt">GreaterThan</span> (<span class="dt">BetterExpr</span> <span class="dt">Int</span>) (<span class="dt">BetterExpr</span> <span class="dt">Int</span>)</code></pre></div>
<p>But these invalid expressions still typecheck:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>t <span class="dt">GreaterThan</span> (<span class="dt">BoolVal</span> <span class="dt">True</span>) (<span class="dt">IntVal</span> <span class="dv">3</span>)
<span class="dt">GreaterThan</span> (<span class="dt">BoolVal</span> <span class="dt">True</span>) (<span class="dt">IntVal</span> <span class="dv">3</span>)<span class="ot"> ::</span> <span class="dt">BetterExpr</span> t</code></pre></div>
<p>We can hack around this by defining our own value constructors that enforce the correct types, and only exporting those. That way, users of our module won’t be able to construct invalid types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Expression</span> (<span class="dt">BetterExpr</span>, boolVal, intVal, greaterThan, multInt) <span class="kw">where</span>

<span class="ot">intVal ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span>
intVal <span class="fu">=</span> <span class="dt">IntVal</span>

<span class="ot">boolVal ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Bool</span>
boolVal <span class="fu">=</span> <span class="dt">BoolVal</span>

<span class="ot">greaterThan ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Bool</span>
greaterThan <span class="fu">=</span> <span class="dt">GreaterThan</span>

<span class="co">-- etc</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> greaterThan (boolVal <span class="dt">True</span>) (intVal <span class="dv">3</span>)

<span class="st">"Couldn't match type ‘Bool’ with ‘Int’</span>
<span class="st">    Expected type: BetterExpr Int</span>
<span class="st">      Actual type: BetterExpr Bool"</span></code></pre></div>
<h2 id="evaluating-better">Evaluating better</h2>
<p>Let’s try to evaluate our <code>BetterExpr</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evaluate ::</span> <span class="dt">BetterExpr</span> t <span class="ot">-&gt;</span> t
evaluate (<span class="dt">IntVal</span> i) <span class="fu">=</span> i
evaluate (<span class="dt">BoolVal</span> b) <span class="fu">=</span> b
<span class="co">-- etc</span></code></pre></div>
<p>Unfortunately, this doesn’t compile. This is because the type parameter <code>t</code> in <code>BetterExpr t</code> isn’t at all related to the types mentioned in the constructors! For instance, we could define:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">IntVal</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Bool</span></code></pre></div>
<p>This typechecks! We can think of <code>IntVal</code> and other value constructors as functions that return a <code>BetterExpr t</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- The value constructors of this type:</span>
<span class="kw">data</span> <span class="dt">BetterExpr</span> t <span class="fu">=</span>
    <span class="dt">IntVal</span> <span class="dt">Int</span>
  <span class="fu">|</span> <span class="dt">BoolVal</span> <span class="dt">Bool</span>
  <span class="fu">|</span> <span class="dt">MultInt</span> (<span class="dt">BetterExpr</span> <span class="dt">Int</span>) (<span class="dt">BetterExpr</span> <span class="dt">Int</span>)
  <span class="fu">|</span> <span class="dt">AddInt</span> (<span class="dt">BetterExpr</span> <span class="dt">Int</span>) (<span class="dt">BetterExpr</span> <span class="dt">Int</span>)
  <span class="fu">|</span> <span class="dt">GreaterThan</span> (<span class="dt">BetterExpr</span> <span class="dt">Int</span>) (<span class="dt">BetterExpr</span> <span class="dt">Int</span>)

<span class="co">-- can be written as:</span>

<span class="dt">IntVal</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> t
<span class="dt">BoolVal</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> t
<span class="dt">MultInt</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> t
<span class="dt">AddInt</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> t
<span class="dt">GreaterThan</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> t</code></pre></div>
<p>This syntax makes the problem clear: all value constructors underspecify their return type. This syntax also makes the solution obvious- just specify the return types! This is exactly what GADTs allow us to do.</p>
<h3 id="gadts">GADTs</h3>
<p>We need to turn on a language extension to use GADTs:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE GADTs #-}</span></code></pre></div>
<p>Now we can write type declarations exactly how we want:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">BetterExpr</span> t <span class="kw">where</span>
  <span class="dt">IntVal</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span>
  <span class="dt">BoolVal</span><span class="ot"> ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Bool</span>
  <span class="dt">MultInt</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span>
  <span class="dt">AddInt</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span>
  <span class="dt">GreaterThan</span><span class="ot"> ::</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">BetterExpr</span> <span class="dt">Bool</span></code></pre></div>
<p>Invalid expressions that previously typechecked are now rejected by the compiler:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="dt">MultInt</span> (<span class="dt">GreaterThan</span> (<span class="dt">IntVal</span> <span class="dv">3</span>) (<span class="dt">IntVal</span> <span class="dv">2</span>)) (<span class="dt">IntVal</span> <span class="dv">2</span>)
   <span class="st">"Couldn't match type ‘Bool’ with ‘Int’</span>
<span class="st">    Expected type: BetterExpr Int</span>
<span class="st">      Actual type: BetterExpr Bool"</span></code></pre></div>
<p>and writing our evaluator is again extremely straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">eval ::</span> <span class="dt">BetterExpr</span> t <span class="ot">-&gt;</span> t
eval (<span class="dt">IntVal</span> i) <span class="fu">=</span> i
eval (<span class="dt">BoolVal</span> b) <span class="fu">=</span> b
eval (<span class="dt">MultInt</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">*</span> eval e2
eval (<span class="dt">AddInt</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">+</span> eval e2
eval (<span class="dt">GreaterThan</span> e1 e2) <span class="fu">=</span> eval e1 <span class="fu">&gt;</span> eval e2</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> eval <span class="fu">$</span> <span class="dt">MultInt</span> (<span class="dt">IntVal</span> <span class="dv">3</span>) (<span class="dt">IntVal</span> <span class="dv">2</span>)
<span class="dv">6</span>

ghci<span class="fu">&gt;</span> eval <span class="fu">$</span> <span class="dt">GreaterThan</span> (<span class="dt">IntVal</span> <span class="dv">3</span>) (<span class="dt">IntVal</span> <span class="dv">2</span>)
<span class="dt">True</span></code></pre></div>
<p>That’s all for today! Next time we’ll implement GADTs in C#.</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn1"><p>Or more formally, they’re equivalent up to an isomorphism in that they both form a semiring, with types as the operands, product/ sum composition as the binary operator, and <code>Unit</code>/ <code>Void</code> as the respective identity elements.<a href="#fnref1">↩</a></p></li>
</ol>
</div>

<div class="info">
</div>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.1.6/zepto.min.js"></script>
<script type="text/javascript" src="../css/footnote.js"></script>




        <div id="footer">
          <small>Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a></small>
        </div>
      </div>
    </article>
    </main>
  

</body></html>